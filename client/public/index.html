<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/short-logo-16-x-16.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="logo192.png" />
    <link
      href="https://fonts.googleapis.com/css?family=Roboto&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.10.2/css/all.min.css"
      integrity="sha256-zmfNZmXoNWBMemUOo1XUGFfc0ihGGLYdgtJS3KCr/l0="
      crossorigin="anonymous"
    />
    <link
      rel="stylesheet"
      href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
      integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh"
      crossorigin="anonymous"
    />
    <script
      src="https://rawgit.com/SeanFree/Vector2/master/Vector2.js"
      charset="utf-8"
    ></script>
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <title>Impulse</title>
    <style media="screen">
    body {
      background: #0c0c0c;
    }

    #canvas {
      position: absolute;
      z-index: 1;
      top: 0;
      left: 0;
      min-height: calc(100vh - 86px);
      width: 100vw;
      cursor: pointer;
    }

    /* #root {
      color: #fff !important;
    } */

    .canvas-wrapper {
      height: calc(100vh - 86px);
      position: relative;
    }

    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      background-color: rgba(255, 255, 255, 0.15) !important;
      z-index: 2;
      min-height: 100vh;
      width: 100vw;
      /* transform: translate(-50%, -50%); */
    }

    .pointer {
      cursor: pointer;
    }
    </style>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <script type="text/javascript">
      const title = document.title;
      window.addEventListener("blur", () => {
        document.title = "Come back, I miss you.";
      });

      window.addEventListener("focus", () => {
        document.title = title;
      });
    </script>
    <div class="canvas-wrapper w-100">
      <canvas id="canvas"></canvas>
      <div class="overlay d-flex flex-column">
        <div id="root"></div>
      </div>
    </div>
    <script
      src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
      integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"
      integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"
      integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6"
      crossorigin="anonymous"
    ></script>
    <script type="text/javascript">
    ;(function (main) {
      main(this, document, Vector2)
      // Vector2 library included from GitHub
      })(function (window, document, vec2) {
      class Segment {
        constructor (start = new vec2(), end = new vec2(), width) {
          // super(start, end, width)
          this.start = start
          this.end = end
          this.width = width
        }
      }

      class Lightning {
        constructor (center, end, iterations = 5) {
          // super(center, end, iterations)
          this.start = new vec2(center.x, center.y)
          this.end = new vec2(end.x, end.y)
          this.iterations = iterations
          this.life = 0
          this.ttl = 10 // time to live
          this.generateSegments()
        }

        generateSegments () {
          this.segments = []
          this.segments.push(new Segment(this.start, this.end))
          this.branches = Math.round(1 + Math.random() * 2) // random number of branches between 1 and 3
          for (let i = 0; i < this.iterations; i++) {
            // for each number of iterations
            for (let j = this.segments.length; j > 0; j--) {
              // start at end of segments array
              var segmentWidth = 1
              var oldSegment = this.segments[j - 1] // segment to split
              var start = oldSegment.start // get start and end points
              var end = oldSegment.end
              var mid = start.midpoint(end) // get midpoint
              var angle = ((start.angleTo(end, 'deg') - 90) * Math.PI) / 180 // calculate angle (in degrees) perpindicular to angle of current segment then convert to radians
              var offset =
                ((15 - Math.random() * 30) / (i + 1)) *
                (start.distanceTo(end) * 0.025) // offset by random value + scale down offset based on current iteration and distance to end of current segment

              mid.addScalarX(Math.cos(angle) * offset) // add calculated offset along perpindicular angle
              mid.addScalarY(Math.sin(angle) * offset)

              var newSegment1 = new Segment(start, mid, segmentWidth) // create two new segments to replace current segment
              var newSegment2 = new Segment(mid, end, segmentWidth)

              this.segments.splice(j - 1, 1) // remove the old segment

              this.segments.push(newSegment1) // replace the old segment
              this.segments.push(newSegment2)

              if (i < this.branches) {
                // add branches until i is greater than number of branches
                var branchAngle =
                  ((start.angleTo(end, 'deg') + (45 - Math.random() * 90)) *
                    Math.PI) /
                  180 // calculate current angle then offset by random amount between -45 and 45 (degrees) then convert to radians
                var branchStart = mid // start at midpoint
                var branchEnd = new vec2( // offset branch end along calculated angle to length of current segment
                  branchStart.x +
                    Math.cos(branchAngle) * branchStart.distanceTo(end) * 0.85,
                  branchStart.y +
                    Math.sin(branchAngle) * branchStart.distanceTo(end) * 0.85
                )
                var branch = new Segment(branchStart, branchEnd, 0.5)
                this.segments.push(branch)
              }
            }
          }
        }

        update () {
          this.alpha = (this.ttl - this.life) / this.ttl
          for (var i = this.segments.length - 1; i > 1; i--) {
            var segment = this.segments[i]
            segment.start.addRandom(0.8)
          }
          this.life++
        }
      }

      class App {
        constructor () {
          this.tick = 0
          this.bolts = []
          this.initCanvas()
          this.initMouse()
          this.render()
        }

        initCanvas () {
          this.canvas = document.getElementById('canvas')
          this.ctx = this.canvas.getContext('2d')
          this.dimensions = new vec2()
          this.center = new vec2()
          this.resize()
        }

        resize () {
          this.canvas.width = this.dimensions.x = window.innerWidth
          this.canvas.height = this.dimensions.y = window.innerHeight
          this.center.x = this.dimensions.x * 0.5
          this.center.y = this.dimensions.y * 0.5
        }

        initMouse (e) {
          var self = this
          self.mouse = new vec2()
          self.mouseOver = false
          window.onresize = function () {
            self.resize()
          }
          window.onmouseenter = function (e) {
            self.mouseHandler(e)
          }
          window.onmousemove = function (e) {
            self.mouseHandler(e)
          }
          window.onmouseout = function (e) {
            self.mouseHandler(e)
          }
          window.onclick = function (e) {
            self.mouseHandler(e)
          }
        }

        mouseHandler (e) {
          if (e.type === 'mousemove') {
            this.mouse.x = e.clientX
            this.mouse.y = e.clientY
            this.mouseOver = true
          }
          if (e.type === 'mouseout') {
            this.mouseOver = false
          }
          if (e.type === 'click') {
            this.bolts.push(
              new Lightning(this.center, new vec2(this.mouse.x, this.mouse.y), 5)
            )
          }
          if (e.type === 'mouseenter') {
            this.bolts.push(
              new Lightning(this.center, new vec2(this.mouse.x, this.mouse.y), 5)
            )
          }
        }

        draw () {
          this.ctx.fillStyle = 'rgba(0,0,0,0.5)'
          this.ctx.fillRect(0, 0, this.dimensions.x, this.dimensions.y)
          this.ctx.save()
          this.ctx.shadowColor = 'rgba(165,215,255,0.9)'
          this.ctx.shadowBlur = 20
          if (this.bolts.length > 0) {
            for (var i = this.bolts.length - 1; i >= 0; i--) {
              var bolt = this.bolts[i]
              bolt.update()
              for (var j = 0, len = bolt.segments.length; j < len; j++) {
                var segment = bolt.segments[j]
                this.ctx.beginPath()
                this.ctx.strokeStyle =
                  'rgba(165,215,255,' + bolt.alpha.toString() + ')'
                this.ctx.lineWidth = segment.width
                this.ctx.moveTo(segment.start.x, segment.start.y)
                this.ctx.lineTo(segment.end.x, segment.end.y)
                this.ctx.stroke()
                this.ctx.closePath()
              }
              if (bolt.life > bolt.ttl) this.bolts.splice(i, 1)
            }
          }
          this.ctx.fillStyle = 'rgba(200,200,200,1)'
          this.ctx.arc(this.center.x, this.center.y, 5, 0, Math.PI * 180)
          this.ctx.fill()
          this.ctx.restore()
        }

        render () {
          var self = this
          var randomInt = Math.round(Math.random() * 60)
          self.tick++
          if (self.tick % randomInt === 0 && self.mouseOver) {
            for (var i = 0; i < 3; i++) {
              self.bolts.push(
                new Lightning(
                  new vec2(self.center.x, self.center.y),
                  new vec2(self.mouse.x, self.mouse.y),
                  5
                )
              )
            }
          }
          self.draw()
          window.requestAnimationFrame(self.render.bind(self))
        }
      }

      window.onload = function () {
        var app = new App()
        var i = 0
        var interval = window.setInterval(function () {
          // if (i++ > 100) window.clearInterval(interval)
          // else {
          app.bolts.push(
            new Lightning(app.center, new vec2().randomize(app.dimensions), 5)
          )
          // }
        }, 20)
      }

      window.requestAnimationFrame = (function () {
        return (
          window.requestAnimationFrame ||
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame ||
          window.oRequestAnimationFrame ||
          window.msRequestAnimationFrame ||
          function (callback) {
            window.setTimeout(callback, 1000 / 60)
          }
        )
        })()
      })
    </script>
  </body>
</html>
